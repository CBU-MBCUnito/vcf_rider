- // TODO: pass fixed-size vector to be filled with indices.
  let genotypes : Vec<(usize, usize)> = encode_genotypes(&snps_buffer, n_overlapping, n_samples);

[- get MinMax to work]
[- map for Vec<PWM>]
- crate for parameters: https://doc.rust-lang.org/getopts/getopts/index.html   - cargo still do not
 support separate deps for lib and binaries (https://github.com/rust-lang/cargo/issues/1982) - move out the binary in future?
 I do not like the lib very much to tell the truth... will see in the future if n.of arguments gets too cumbersome
 to be managed with the code that I already have.
[- lifetimes!!]
[- read vcf by myself or use lib? gvcf]
- finish loading vcf
- how to have +/min/max/mean in RiderParameters and use it

[- capire iterator cosa fa il for
    // `for` works through an `Iterator` until it returns `None`.
    // Each `Some` value is unwrapped and bound to a variable (here, `i`)
    As a point of convenience for common situations, the for construct turns some collections into iterators using the .into_iterator() method. 
The `iter` method produces an `Iterator` over an array/slice.]

[- capire come mettere print di debug: https://users.rust-lang.org/t/conditional-compilation-for-debug-release/1098]
- implementare i controlli minimali?

- docs
- tests

- indagare differenza array Vec


min_max
    #[unstable(feature = "core", reason = "return type may change")]
    fn min_max(mut self) -> MinMaxResult<Self::Item> where Self: Sized, Self::Item: Ord
    {
        let (mut min, mut max) = match self.next() {
            None => return NoElements,
            Some(x) => {
                match self.next() {
                    None => return OneElement(x),
                    Some(y) => if x <= y {(x, y)} else {(y, x)}
                }
            }
        };

        loop {
            // `first` and `second` are the two next elements we want to look
            // at.  We first compare `first` and `second` (#1). The smaller one
            // is then compared to current minimum (#2). The larger one is
            // compared to current maximum (#3). This way we do 3 comparisons
            // for 2 elements.
            let first = match self.next() {
                None => break,
                Some(x) => x
            };
            let second = match self.next() {
                None => {
                    if first < min {
                        min = first;
                    } else if first >= max {
                        max = first;
                    }
                    break;
                }
                Some(x) => x
            };
            if first <= second {
                if first < min { min = first }
                if second >= max { max = second }
            } else {
                if second < min { min = second }
                if first >= max { max = first }
            }
        }

        MinMax(min, max)
    }


wtf

    // A `ref` borrow on the left side of an assignment is equivalent to
    // an `&` borrow on the right side.
    let ref ref_c1 = c;
    let ref_c2 = &c;

    println!("ref_c1 equals ref_c2: {}", *ref_c1 == *ref_c2);

    let point = Point { x: 0, y: 0 };

    // `ref` is also valid when destructuring a struct.
    let _copy_of_x = {
        // `ref_to_x` is a reference to the `x` field of `point`.
        let Point { x: ref ref_to_x, y: _ } = point;

        // Return a copy of the `x` field of `point`.
        *ref_to_x
    };

    non ho mica capito il destructuring direi...da solo dei nomi per lo scope?

            // Make a `string` literal and print it:
        let static_string = "I'm in read-only memory";
        println!("static_string: {}", static_string);

        // When `static_string` goes out of scope, the reference
        // can no longer be used, but the data remains in the binary.