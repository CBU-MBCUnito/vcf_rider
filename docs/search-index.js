var searchIndex = {};
searchIndex["bitflags"] = {"doc":"A typesafe bitmask flag generator useful for sets of C-style bitmask flags. It can be used for creating typesafe wrappers around C APIs.","items":[[0,"example_generated","bitflags","This module shows an example of code generated by the macro. IT MUST NOT BE USED OUTSIDE THIS CRATE.",null,null],[3,"Flags","bitflags::example_generated","This is the same `Flags` struct defined in the crate level example. Note that this struct is just for documentation purposes only, it must not be used outside this crate.",null,null],[17,"FLAG_A","","",null,null],[17,"FLAG_B","","",null,null],[17,"FLAG_C","","",null,null],[17,"FLAG_ABC","","",null,null],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"cmp","","",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"ordering"}}],[11,"hash","","",0,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",0,{"inputs":[],"output":{"name":"flags"}}],[11,"all","","Returns the set containing all flags.",0,{"inputs":[],"output":{"name":"flags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",0,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",0,{"inputs":[{"name":"u32"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",0,{"inputs":[{"name":"u32"}],"output":{"name":"flags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"set","","Inserts or removes the specified flags depending on the passed value.",0,{"inputs":[{"name":"self"},{"name":"flags"},{"name":"bool"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitor_assign","","Adds the set of flags.",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitxor_assign","","Toggles the set of flags.",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"sub_assign","","Disables all flags enabled in the set.",0,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",0,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"extend","","",0,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",0,{"inputs":[{"name":"t"}],"output":{"name":"flags"}}],[14,"bitflags","bitflags","The macro used to generate the flag structure.",null,null]],"paths":[[3,"Flags"]]};
searchIndex["byteorder"] = {"doc":"This crate provides convenience methods for encoding and decoding numbers in either big-endian or little-endian order.","items":[[4,"BigEndian","byteorder","Defines big-endian serialization.",null,null],[4,"LittleEndian","","Defines little-endian serialization.",null,null],[6,"BE","","A type alias for `BigEndian`.",null,null],[6,"LE","","A type alias for `LittleEndian`.",null,null],[6,"NetworkEndian","","Defines network byte order serialization.",null,null],[6,"NativeEndian","","Defines system native-endian serialization.",null,null],[8,"ReadBytesExt","","Extends `Read` with methods for reading numbers. (For `std::io`.)",null,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_u24","","Reads an unsigned 24 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_i24","","Reads a signed 24 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"result"}}],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"result"}}],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_u16_into","","Reads a sequence of unsigned 16 bit integers from the underlying reader.",0,null],[11,"read_u32_into","","Reads a sequence of unsigned 32 bit integers from the underlying reader.",0,null],[11,"read_u64_into","","Reads a sequence of unsigned 64 bit integers from the underlying reader.",0,null],[11,"read_i16_into","","Reads a sequence of signed 16 bit integers from the underlying reader.",0,null],[11,"read_i32_into","","Reads a sequence of signed 32 bit integers from the underlying reader.",0,null],[11,"read_i64_into","","Reads a sequence of signed 64 bit integers from the underlying reader.",0,null],[11,"read_f32_into_unchecked","","Reads a sequence of IEEE754 single-precision (4 bytes) floating point numbers from the underlying reader.",0,null],[11,"read_f64_into_unchecked","","Reads a sequence of IEEE754 double-precision (8 bytes) floating point numbers from the underlying reader.",0,null],[8,"WriteBytesExt","","Extends `Write` with methods for writing numbers. (For `std::io`.)",null,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"result"}}],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i8"}],"output":{"name":"result"}}],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u16"}],"output":{"name":"result"}}],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i16"}],"output":{"name":"result"}}],[11,"write_u24","","Writes an unsigned 24 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"write_i24","","Writes a signed 24 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"result"}}],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i64"}],"output":{"name":"result"}}],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"usize"}],"output":{"name":"result"}}],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i64"},{"name":"usize"}],"output":{"name":"result"}}],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"f32"}],"output":{"name":"result"}}],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"result"}}],[8,"ByteOrder","","ByteOrder describes types that can serialize integers as bytes.",null,null],[10,"read_u16","","Reads an unsigned 16 bit integer from `buf`.",2,null],[11,"read_u24","","Reads an unsigned 24 bit integer from `buf`, stored in u32.",2,null],[10,"read_u32","","Reads an unsigned 32 bit integer from `buf`.",2,null],[10,"read_u64","","Reads an unsigned 64 bit integer from `buf`.",2,null],[10,"read_uint","","Reads an unsigned n-bytes integer from `buf`.",2,null],[10,"write_u16","","Writes an unsigned 16 bit integer `n` to `buf`.",2,null],[11,"write_u24","","Writes an unsigned 24 bit integer `n` to `buf`, stored in u32.",2,null],[10,"write_u32","","Writes an unsigned 32 bit integer `n` to `buf`.",2,null],[10,"write_u64","","Writes an unsigned 64 bit integer `n` to `buf`.",2,null],[10,"write_uint","","Writes an unsigned integer `n` to `buf` using only `nbytes`.",2,null],[11,"read_i16","","Reads a signed 16 bit integer from `buf`.",2,null],[11,"read_i24","","Reads a signed 24 bit integer from `buf`, stored in i32.",2,null],[11,"read_i32","","Reads a signed 32 bit integer from `buf`.",2,null],[11,"read_i64","","Reads a signed 64 bit integer from `buf`.",2,null],[11,"read_int","","Reads a signed n-bytes integer from `buf`.",2,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number.",2,null],[11,"write_i16","","Writes a signed 16 bit integer `n` to `buf`.",2,null],[11,"write_i24","","Writes a signed 24 bit integer `n` to `buf`, stored in i32.",2,null],[11,"write_i32","","Writes a signed 32 bit integer `n` to `buf`.",2,null],[11,"write_i64","","Writes a signed 64 bit integer `n` to `buf`.",2,null],[11,"write_int","","Writes a signed integer `n` to `buf` using only `nbytes`.",2,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number.",2,null],[10,"read_u16_into","","Reads unsigned 16 bit integers from `src` into `dst`.",2,null],[10,"read_u32_into","","Reads unsigned 32 bit integers from `src` into `dst`.",2,null],[10,"read_u64_into","","Reads unsigned 64 bit integers from `src` into `dst`.",2,null],[11,"read_i16_into","","Reads signed 16 bit integers from `src` to `dst`.",2,null],[11,"read_i32_into","","Reads signed 32 bit integers from `src` into `dst`.",2,null],[11,"read_i64_into","","Reads signed 64 bit integers from `src` into `dst`.",2,null],[11,"read_f32_into_unchecked","","Reads IEEE754 single-precision (4 bytes) floating point numbers from `src` into `dst`.",2,null],[11,"read_f64_into_unchecked","","Reads IEEE754 single-precision (4 bytes) floating point numbers from `src` into `dst`.",2,null],[10,"write_u16_into","","Writes unsigned 16 bit integers from `src` into `dst`.",2,null],[10,"write_u32_into","","Writes unsigned 32 bit integers from `src` into `dst`.",2,null],[10,"write_u64_into","","Writes unsigned 64 bit integers from `src` into `dst`.",2,null],[11,"write_i16_into","","Writes signed 16 bit integers from `src` into `dst`.",2,null],[11,"write_i32_into","","Writes signed 32 bit integers from `src` into `dst`.",2,null],[11,"write_i64_into","","Writes signed 64 bit integers from `src` into `dst`.",2,null],[11,"write_f32_into","","Writes IEEE754 single-precision (4 bytes) floating point numbers from `src` into `dst`.",2,null],[11,"write_f64_into","","Writes IEEE754 double-precision (8 bytes) floating point numbers from `src` into `dst`.",2,null],[10,"from_slice_u16","","Converts the given slice of unsigned 16 bit integers to a particular endianness.",2,null],[10,"from_slice_u32","","Converts the given slice of unsigned 32 bit integers to a particular endianness.",2,null],[10,"from_slice_u64","","Converts the given slice of unsigned 64 bit integers to a particular endianness.",2,null],[11,"from_slice_i16","","Converts the given slice of signed 16 bit integers to a particular endianness.",2,null],[11,"from_slice_i32","","Converts the given slice of signed 32 bit integers to a particular endianness.",2,null],[11,"from_slice_i64","","Converts the given slice of signed 64 bit integers to a particular endianness.",2,null],[10,"from_slice_f32","","Converts the given slice of IEEE754 single-precision (4 bytes) floating point numbers to a particular endianness.",2,null],[10,"from_slice_f64","","Converts the given slice of IEEE754 double-precision (8 bytes) floating point numbers to a particular endianness.",2,null],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bigendian"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",3,null],[11,"cmp","","",3,{"inputs":[{"name":"self"},{"name":"bigendian"}],"output":{"name":"ordering"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"bigendian"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",3,{"inputs":[{"name":"self"},{"name":"bigendian"}],"output":{"name":"option"}}],[11,"default","","",3,{"inputs":[],"output":{"name":"bigendian"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"littleendian"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",4,null],[11,"cmp","","",4,{"inputs":[{"name":"self"},{"name":"littleendian"}],"output":{"name":"ordering"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"littleendian"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",4,{"inputs":[{"name":"self"},{"name":"littleendian"}],"output":{"name":"option"}}],[11,"default","","",4,{"inputs":[],"output":{"name":"littleendian"}}],[11,"read_u16","","",3,null],[11,"read_u32","","",3,null],[11,"read_u64","","",3,null],[11,"read_uint","","",3,null],[11,"write_u16","","",3,null],[11,"write_u32","","",3,null],[11,"write_u64","","",3,null],[11,"write_uint","","",3,null],[11,"read_u16_into","","",3,null],[11,"read_u32_into","","",3,null],[11,"read_u64_into","","",3,null],[11,"write_u16_into","","",3,null],[11,"write_u32_into","","",3,null],[11,"write_u64_into","","",3,null],[11,"from_slice_u16","","",3,null],[11,"from_slice_u32","","",3,null],[11,"from_slice_u64","","",3,null],[11,"from_slice_f32","","",3,null],[11,"from_slice_f64","","",3,null],[11,"read_u16","","",4,null],[11,"read_u32","","",4,null],[11,"read_u64","","",4,null],[11,"read_uint","","",4,null],[11,"write_u16","","",4,null],[11,"write_u32","","",4,null],[11,"write_u64","","",4,null],[11,"write_uint","","",4,null],[11,"read_u16_into","","",4,null],[11,"read_u32_into","","",4,null],[11,"read_u64_into","","",4,null],[11,"write_u16_into","","",4,null],[11,"write_u32_into","","",4,null],[11,"write_u64_into","","",4,null],[11,"from_slice_u16","","",4,null],[11,"from_slice_u32","","",4,null],[11,"from_slice_u64","","",4,null],[11,"from_slice_f32","","",4,null],[11,"from_slice_f64","","",4,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_u24","","Reads an unsigned 24 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_i24","","Reads a signed 24 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"result"}}],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"result"}}],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_u16_into","","Reads a sequence of unsigned 16 bit integers from the underlying reader.",0,null],[11,"read_u32_into","","Reads a sequence of unsigned 32 bit integers from the underlying reader.",0,null],[11,"read_u64_into","","Reads a sequence of unsigned 64 bit integers from the underlying reader.",0,null],[11,"read_i16_into","","Reads a sequence of signed 16 bit integers from the underlying reader.",0,null],[11,"read_i32_into","","Reads a sequence of signed 32 bit integers from the underlying reader.",0,null],[11,"read_i64_into","","Reads a sequence of signed 64 bit integers from the underlying reader.",0,null],[11,"read_f32_into_unchecked","","Reads a sequence of IEEE754 single-precision (4 bytes) floating point numbers from the underlying reader.",0,null],[11,"read_f64_into_unchecked","","Reads a sequence of IEEE754 double-precision (8 bytes) floating point numbers from the underlying reader.",0,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"result"}}],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i8"}],"output":{"name":"result"}}],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u16"}],"output":{"name":"result"}}],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i16"}],"output":{"name":"result"}}],[11,"write_u24","","Writes an unsigned 24 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"write_i24","","Writes a signed 24 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"result"}}],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i64"}],"output":{"name":"result"}}],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"usize"}],"output":{"name":"result"}}],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i64"},{"name":"usize"}],"output":{"name":"result"}}],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"f32"}],"output":{"name":"result"}}],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"result"}}]],"paths":[[8,"ReadBytesExt"],[8,"WriteBytesExt"],[8,"ByteOrder"],[4,"BigEndian"],[4,"LittleEndian"]]};
searchIndex["custom_derive"] = {"doc":"Note: This crate has been superseded by `macro-attr`.","items":[],"paths":[]};
searchIndex["lazy_static"] = {"doc":"A macro for declaring lazily evaluated statics.","items":[[5,"initialize","lazy_static","Takes a shared reference to a lazy static and initializes it if it has not been already.",null,{"inputs":[{"name":"t"}],"output":null}],[8,"LazyStatic","","Support trait for enabling a few common operation on lazy static values.",null,null],[14,"lazy_static","","",null,null]],"paths":[]};
searchIndex["matches"] = {"doc":"","items":[[14,"matches","matches","Check if an expression matches a refutable pattern.",null,null],[14,"assert_matches","","Assert that an expression matches a refutable pattern.",null,null],[14,"debug_assert_matches","","Assert that an expression matches a refutable pattern using debug assertions.",null,null]],"paths":[]};
searchIndex["unicode_xid"] = {"doc":"Determine if a `char` is a valid identifier for a parser and/or lexer according to Unicode Standard Annex #31 rules.","items":[[17,"UNICODE_VERSION","unicode_xid","The version of Unicode that this version of unicode-xid is based on.",null,null],[8,"UnicodeXID","","Methods for determining if a character is a valid identifier character.",null,null],[10,"is_xid_start","","Returns whether the specified character satisfies the 'XID_Start' Unicode property.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_xid_continue","","Returns whether the specified `char` satisfies the 'XID_Continue' Unicode property.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}]],"paths":[[8,"UnicodeXID"]]};
searchIndex["vcf_rider"] = {"doc":"vcf_rider: a library to efficiently compute score on individual genomes starting from vcf files ","items":[[0,"fasta","vcf_rider","The module used for reading the fasta file representing the genome of interest. Right now it should contain a single chromosome to be used with `vcf_rider`, but the module can handle also multifasta files. The id of the fasta should be the same used in the vcf file and with genomic regions represented in the used bed.",null,null],[3,"Fasta","vcf_rider::fasta","Struct representing a fasta: its id, then the sequence (encoded by a vector of u8, with ACGTN -> 01234) and the background frequencies of nucleotides (needed to compute TBA values)",null,null],[12,"id","","The id of this fasta",0,null],[12,"sequence","","The u8 encoded sequence",0,null],[12,"background","","Background frequencies of ACGT in this fasta",0,null],[3,"FastaReader","","Struct used to read fasta files. It will be implement an Iterator of `Fasta` structs. The String buffer is used to get characters from the `BufReader` one by one and convert them to our internal `Vec<u8>` representation.",null,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"open","","Opens a fasta file returning a `Result<FastaReader>`. # Arguments",1,{"inputs":[{"name":"file"}],"output":{"name":"result"}}],[11,"open_path","","Opens a fasta file returning a `Result<FastaReader>`. # Arguments",1,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"next","","",1,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"pwm","vcf_rider","Module representing Positional Weight Matrixes and that is able to compute their score on a given sequence.",null,null],[3,"Matrix","vcf_rider::pwm","Struct used to represent PWM likelihoods/nucleotide frequencies.  ncols is used to be able to represent 4 and 5 nucleotides PWMs (to manage N in sequences). No consistency checks are performed for get/set operations for efficiency.",null,null],[3,"PWM","","Struct representing a whole Positional Weight Matrix.",null,null],[12,"name","","The name of this PWM",2,null],[12,"ll","","A `Matrix` storing likelihoods for this PWM",2,null],[12,"llrc","","A `Matrix` storing reverse complement likelihoods for this PWM. i.e. its elements 0,0 has the likelihood of a T (reverse of A) in the last position of the PWM - used to efficiently score the reverse complement sequence while analyzing sequences going forward.",2,null],[12,"freq","","A `Matrix` storing the original frequencies for nucleotides, these becomes likelihoods when divided by a given sequence background.",2,null],[3,"PWMReader","","Struct used to read PWM. It will be implement an Iterator of `PWM` structs. The String buffer is used to get characters from the `BufReader` one by one and load the `freq` for the loaded `PWM` structs. The expected format is the same used by matrix_rider in C, therefore a tab delimited file with these columns: pwm_name, pos, count_a, count_c, count_g, count_t pos is ignored, count_x should be positive integer different from 0.",null,null],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new matrix with n columns. # Arguments",3,{"inputs":[{"name":"usize"}],"output":{"name":"matrix"}}],[11,"with_capacity","","Creates a new matrix preallocated for len elements. Warning: len is not checked to be compatible with n.",3,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"matrix"}}],[11,"len","","Returns the number of rows of this `Matrix`",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"push_row_4","","Adds a 4 element row to this `Matrix`. No checks of compatibility with `self.ncols`.",3,{"inputs":[{"name":"self"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":null}],[11,"push_row_5","","Adds a 5 element row to this `Matrix`. No checks of compatibility with `self.ncols`.",3,{"inputs":[{"name":"self"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":null}],[11,"get","","Returns the element in row, col of this `Matrix`. No boundary checks are performed!",3,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f64"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"get_length","","",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_name","","",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"get_score","","Computes the score for this `PWM` on a given sequence starting at the given pos. The returned score is the highest between the \"straight\" one and the one on the reverse complement. We do not need checks on lengths here because we will perform then in the library at a (hopefully) least repeated step. The library only calls get score for sequences with lengths sufficient to host the PWM starting at pos. # Arguments",2,null],[11,"compute_ll","","Given a `PWM` that has frequencies loaded and some background frequencies it fills `ll` and `ll_rc`. # Arguments",2,{"inputs":[{"name":"self"},{"name":"vec"}],"output":null}],[11,"open","","Opens a PWM file returning a `Result<PWMReader>`. # Arguments",4,{"inputs":[{"name":"file"}],"output":{"name":"result"}}],[11,"open_path","","Opens a pwm file returning a `Result<PWMReader>`. # Arguments",4,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"next","","",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"rider","vcf_rider","Main module of vcf_rider, its function `get_scores` is the entry point of the whole analysis.",null,null],[3,"RiderParameters","vcf_rider::rider","",null,null],[12,"min_len","","",5,null],[12,"max_len","","",5,null],[12,"parameters","","",5,null],[5,"get_scores","","",null,{"inputs":[{"name":"riderparameters"},{"name":"str"},{"name":"reader"},{"name":"str"},{"name":"option"}],"output":null}],[5,"match_indexes","","",null,{"inputs":[{"name":"bitvec"},{"name":"vec"},{"name":"vec"}],"output":{"name":"bool"}}],[5,"find_overlapping_snps","","Function that advances on the VcfReader (Iterator of Mutation) until the first snp that does not overlap with the given window, putting in snps_buffer all the overlapping snps and their number and then the first not overlapping snp.",null,{"inputs":[{"name":"coordinate"},{"name":"i"},{"name":"vecdeque"}],"output":{"name":"usize"}}],[5,"print_overlapping","","",null,{"inputs":[{"name":"vecdeque"},{"name":"usize"},{"name":"write"},{"name":"record"}],"output":null}],[5,"obtain_seq","","",null,{"inputs":[{"name":"coordinate"},{"name":"vecdeque"},{"name":"vec"},{"name":"fasta"},{"name":"vec"},{"name":"vec"},{"name":"u64"}],"output":null}],[5,"encode_genotypes","","",null,{"inputs":[{"name":"vecdeque"},{"name":"vec"},{"name":"vec"},{"name":"usize"},{"name":"vec"}],"output":{"name":"vec"}}],[8,"CanScoreSequence","","Our vcf_rider main function will receive a Vec<T: CanScoreSequence> and call it for every T on subsequences of the genomes of the samples doing it only for each variant subsequence once. This trait will need to be able to compute a score on a given sequence, represented by a splice of an array of u8 [TODO] starting for a given position (it is guaranteed by the lib that the used position will be given inside the sequence, i.e. sequence.len() - self.get_length() >= 0).",null,null],[10,"get_score","","Returns a score for the given sequence starting at position pos.",6,null],[10,"get_length","","Returns the length of sequence that this object can score.",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"get_name","","Returns the name of this object.",6,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[0,"mutations","vcf_rider","Module able to load mutations from a vcf file.",null,null],[3,"Coordinate","vcf_rider::mutations","",null,null],[12,"chr","","",7,null],[12,"start","","",7,null],[12,"end","","",7,null],[3,"Mutation","","",null,null],[12,"id","","",8,null],[12,"pos","","",8,null],[12,"sequence_ref","","",8,null],[12,"sequence_alt","","",8,null],[12,"genotypes","","",8,null],[12,"is_indel","","",8,null],[12,"indel_len","","",8,null],[3,"VcfReader","","",null,null],[12,"samples","","",9,null],[4,"Position","","",null,null],[13,"Before","","",10,null],[13,"Overlapping","","",10,null],[13,"After","","",10,null],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"coordinate"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"name":"bool"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"relative_position","","Returns the position of self relative to other.",7,{"inputs":[{"name":"self"},{"name":"coordinate"}],"output":{"name":"position"}}],[11,"relative_position_overlap","","",7,null],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"mutation"}}],[11,"open_path","","",9,{"inputs":[{"name":"str"},{"name":"bool"}],"output":{"name":"result"}}],[11,"next","","",9,{"inputs":[{"name":"self"}],"output":{"name":"option"}}]],"paths":[[3,"Fasta"],[3,"FastaReader"],[3,"PWM"],[3,"Matrix"],[3,"PWMReader"],[3,"RiderParameters"],[8,"CanScoreSequence"],[3,"Coordinate"],[3,"Mutation"],[3,"VcfReader"],[4,"Position"]]};
initSearch(searchIndex);
