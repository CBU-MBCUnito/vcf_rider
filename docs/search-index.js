var searchIndex = {};
searchIndex["vcf_rider"] = {"doc":"vcf_rider: a library to efficiently compute score on individual genomes starting from vcf files ","items":[[0,"fasta","vcf_rider","The module used for reading the fasta file representing the genome of interest. Right now it should contain a single chromosome to be used with `vcf_rider`, but the module can handle also multifasta files. The id of the fasta should be the same used in the vcf file and with genomic regions represented in the used bed.",null,null],[3,"Fasta","vcf_rider::fasta","Struct representing a fasta: its id, then the sequence (encoded by a vector of u8, with ACGTN -> 01234) and the background frequencies of nucleotides (needed to compute TBA values)",null,null],[12,"id","","The id of this fasta",0,null],[12,"sequence","","The u8 encoded sequence",0,null],[12,"background","","Background frequencies of ACGT in this fasta",0,null],[3,"FastaReader","","Struct used to read fasta files. It will be implement an Iterator of `Fasta` structs. The String buffer is used to get characters from the `BufReader` one by one and convert them to our internal `Vec<u8>` representation.",null,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"open","","Opens a fasta file returning a `Result<FastaReader>`. # Arguments",1,{"inputs":[{"name":"file"}],"output":{"name":"result"}}],[11,"open_path","","Opens a fasta file returning a `Result<FastaReader>`. # Arguments",1,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"next","","",1,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"pwm","vcf_rider","Module representing Positional Weight Matrixes and that is able to compute their score on a given sequence.",null,null],[3,"Matrix","vcf_rider::pwm","Struct used to represent PWM likelihoods/nucleotide frequencies.  ncols is used to be able to represent 4 and 5 nucleotides PWMs (to manage N in sequences). No consistency checks are performed for get/set operations for efficiency.",null,null],[3,"PWM","","Struct representing a whole Positional Weight Matrix.",null,null],[12,"name","","The name of this PWM",2,null],[12,"ll","","A `Matrix` storing likelihoods for this PWM",2,null],[12,"llrc","","A `Matrix` storing reverse complement likelihoods for this PWM. i.e. its elements 0,0 has the likelihood of a T (reverse of A) in the last position of the PWM - used to efficiently score the reverse complement sequence while analyzing sequences going forward.",2,null],[12,"freq","","A `Matrix` storing the original frequencies for nucleotides, these becomes likelihoods when divided by a given sequence background.",2,null],[3,"PWMReader","","Struct used to read PWM. It will be implement an Iterator of `PWM` structs. The String buffer is used to get characters from the `BufReader` one by one and load the `freq` for the loaded `PWM` structs. The expected format is the same used by matrix_rider in C, therefore a tab delimited file with these columns: pwm_name, pos, count_a, count_c, count_g, count_t pos is ignored, count_x should be positive integer different from 0.",null,null],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new matrix with n columns. # Arguments",3,{"inputs":[{"name":"usize"}],"output":{"name":"matrix"}}],[11,"with_capacity","","Creates a new matrix preallocated for len elements. Warning: len is not checked to be compatible with n.",3,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"matrix"}}],[11,"len","","Returns the number of rows of this `Matrix`",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"push_row_4","","Adds a 4 element row to this `Matrix`. No checks of compatibility with `self.ncols`.",3,{"inputs":[{"name":"self"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":null}],[11,"push_row_5","","Adds a 5 element row to this `Matrix`. No checks of compatibility with `self.ncols`.",3,{"inputs":[{"name":"self"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":null}],[11,"get","","Returns the element in row, col of this `Matrix`. No boundary checks are performed!",3,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f64"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"get_length","","",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_name","","",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"get_score","","Computes the score for this `PWM` on a given sequence starting at the given pos. The returned score is the highest between the \"straight\" one and the one on the reverse complement. We do not need checks on lengths here because we will perform then in the library at a (hopefully) least repeated step. The library only calls get score for sequences with lengths sufficient to host the PWM starting at pos. # Arguments",2,null],[11,"compute_ll","","Given a `PWM` that has frequencies loaded and some background frequencies it fills `ll` and `ll_rc`. # Arguments",2,{"inputs":[{"name":"self"},{"name":"vec"}],"output":null}],[11,"open","","Opens a PWM file returning a `Result<PWMReader>`. # Arguments",4,{"inputs":[{"name":"file"}],"output":{"name":"result"}}],[11,"open_path","","Opens a pwm file returning a `Result<PWMReader>`. # Arguments",4,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"next","","",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"rider","vcf_rider","Main module of vcf_rider, its function `get_scores` is the entry point of the whole analysis.",null,null],[3,"RiderParameters","vcf_rider::rider","",null,null],[12,"min_len","","",5,null],[12,"max_len","","",5,null],[12,"parameters","","",5,null],[5,"get_scores","","",null,{"inputs":[{"name":"riderparameters"},{"name":"str"},{"name":"reader"},{"name":"str"},{"name":"option"}],"output":null}],[5,"match_indexes","","",null,{"inputs":[{"name":"bitvec"},{"name":"vec"},{"name":"vec"}],"output":{"name":"bool"}}],[5,"find_overlapping_snps","","Function that advances on the VcfReader (Iterator of Mutation) until the first snp that does not overlap with the given window, putting in snps_buffer all the overlapping snps and their number and then the first not overlapping snp.",null,{"inputs":[{"name":"coordinate"},{"name":"i"},{"name":"vecdeque"}],"output":{"name":"usize"}}],[5,"print_overlapping","","",null,{"inputs":[{"name":"vecdeque"},{"name":"usize"},{"name":"write"},{"name":"record"}],"output":null}],[5,"obtain_seq","","",null,{"inputs":[{"name":"coordinate"},{"name":"vecdeque"},{"name":"vec"},{"name":"fasta"},{"name":"vec"},{"name":"vec"},{"name":"u64"}],"output":null}],[5,"encode_genotypes","","",null,{"inputs":[{"name":"vecdeque"},{"name":"vec"},{"name":"vec"},{"name":"usize"},{"name":"vec"}],"output":{"name":"vec"}}],[8,"CanScoreSequence","","Our vcf_rider main function will receive a Vec<T: CanScoreSequence> and call it for every T on subsequences of the genomes of the samples doing it only for each variant subsequence once. This trait will need to be able to compute a score on a given sequence, represented by a splice of an array of u8 [TODO] starting for a given position (it is guaranteed by the lib that the used position will be given inside the sequence, i.e. sequence.len() - self.get_length() >= 0).",null,null],[10,"get_score","","Returns a score for the given sequence starting at position pos.",6,null],[10,"get_length","","Returns the length of sequence that this object can score.",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"get_name","","Returns the name of this.",6,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[0,"mutations","vcf_rider","Module able to load mutations from a vcf file.",null,null],[3,"Coordinate","vcf_rider::mutations","",null,null],[12,"chr","","",7,null],[12,"start","","",7,null],[12,"end","","",7,null],[3,"Mutation","","",null,null],[12,"id","","",8,null],[12,"pos","","",8,null],[12,"sequence_ref","","",8,null],[12,"sequence_alt","","",8,null],[12,"genotypes","","",8,null],[12,"is_indel","","",8,null],[12,"indel_len","","",8,null],[3,"VcfReader","","",null,null],[12,"samples","","",9,null],[4,"Position","","",null,null],[13,"Before","","",10,null],[13,"Overlapping","","",10,null],[13,"After","","",10,null],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"coordinate"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"name":"bool"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"relative_position","","Returns the position of self relative to other.",7,{"inputs":[{"name":"self"},{"name":"coordinate"}],"output":{"name":"position"}}],[11,"relative_position_overlap","","",7,null],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"mutation"}}],[11,"open_path","","",9,{"inputs":[{"name":"str"},{"name":"bool"}],"output":{"name":"result"}}],[11,"next","","",9,{"inputs":[{"name":"self"}],"output":{"name":"option"}}]],"paths":[[3,"Fasta"],[3,"FastaReader"],[3,"PWM"],[3,"Matrix"],[3,"PWMReader"],[3,"RiderParameters"],[8,"CanScoreSequence"],[3,"Coordinate"],[3,"Mutation"],[3,"VcfReader"],[4,"Position"]]};
initSearch(searchIndex);
