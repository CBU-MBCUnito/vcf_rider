var searchIndex = {};
searchIndex["vcf_rider"] = {"doc":"vcf_rider: a library to efficiently compute score on individual genomes starting from vcf files","items":[[0,"fasta","vcf_rider","The module used for reading the fasta file representing the genome of interest. Right now it should contain a single chromosome to be used with `vcf_rider`, but the module can handle also multifasta files. The id of the fasta should be the same used in the vcf file and with genomic regions represented in the used bed.",null,null],[3,"Fasta","vcf_rider::fasta","Struct representing a fasta: its id, then the sequence (encoded by a vector of u8, with ACGTN -> 01234) and the background frequencies of nucleotides (needed to compute TBA values)",null,null],[12,"id","","The id of this fasta",0,null],[12,"sequence","","The u8 encoded sequence",0,null],[12,"background","","Background frequences of ACGT in this fasta",0,null],[3,"FastaReader","","Struct used to read fasta files. It will be implement an Iterator of Fasta structs. The String buffer is used to get characters from the BufReader one by one and convert them to our internal Vec<u8> representation.",null,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"open","","Opens a fasta file returning a `Result<FastaReader>`. # Arguments",1,{"inputs":[{"name":"file"}],"output":{"name":"result"}}],[11,"open_path","","Opens a fasta file returning a `Result<FastaReader>`. # Arguments",1,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"next","","",1,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"pwm","vcf_rider","",null,null],[3,"Matrix","vcf_rider::pwm","",null,null],[3,"PWM","","",null,null],[12,"name","","",2,null],[12,"ll","","",2,null],[12,"llrc","","",2,null],[12,"freq","","",2,null],[3,"PWMReader","","",null,null],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",3,{"inputs":[{"name":"usize"}],"output":{"name":"matrix"}}],[11,"with_capacity","","",3,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"matrix"}}],[11,"len","","",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"push_row_4","","",3,{"inputs":[{"name":"self"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":null}],[11,"push_row_5","","",3,{"inputs":[{"name":"self"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":null}],[11,"get","","",3,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f64"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"get_length","","",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_name","","",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"get_score","","",2,null],[11,"compute_ll","","",2,{"inputs":[{"name":"self"},{"name":"vec"}],"output":null}],[11,"open","","",4,{"inputs":[{"name":"file"}],"output":{"name":"result"}}],[11,"open_path","","",4,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"next","","",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"rider","vcf_rider","",null,null],[3,"RiderParameters","vcf_rider::rider","",null,null],[12,"min_len","","",5,null],[12,"max_len","","",5,null],[12,"parameters","","",5,null],[5,"get_scores","","",null,{"inputs":[{"name":"riderparameters"},{"name":"str"},{"name":"reader"},{"name":"str"},{"name":"option"}],"output":null}],[5,"match_indexes","","",null,{"inputs":[{"name":"bitvec"},{"name":"vec"},{"name":"vec"}],"output":{"name":"bool"}}],[5,"find_overlapping_snps","","Function that advances on the VcfReader (Iterator of Mutation) until the first snp that does not overlap with the given window, putting in snps_buffer all the overlapping snps and their number and then the first not overlapping snp.",null,{"inputs":[{"name":"coordinate"},{"name":"i"},{"name":"vecdeque"}],"output":{"name":"usize"}}],[5,"print_overlapping","","",null,{"inputs":[{"name":"vecdeque"},{"name":"usize"},{"name":"write"},{"name":"record"}],"output":null}],[5,"obtain_seq","","",null,{"inputs":[{"name":"coordinate"},{"name":"vecdeque"},{"name":"vec"},{"name":"fasta"},{"name":"vec"},{"name":"vec"},{"name":"u64"}],"output":null}],[5,"encode_genotypes","","",null,{"inputs":[{"name":"vecdeque"},{"name":"vec"},{"name":"vec"},{"name":"usize"},{"name":"vec"}],"output":{"name":"vec"}}],[8,"CanScoreSequence","","Our vcf_rider main function will receive a Vec<T: CanScoreSequence> and call it for every T on subsequences of the genomes of the samples doing it only for each variant subsequence once. This trait will need to be able to compute a score on a given sequence, represented by a splice of an array of u8 [TODO] starting for a given position (it is guaranteed by the lib that the used position will be given inside the sequence, i.e. sequence.len() - self.get_length() >= 0).",null,null],[10,"get_score","","Returns a score for the given sequence starting at position pos.",6,null],[10,"get_length","","Returns the length of sequence that this object can score.",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"get_name","","Returns the name of this.",6,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[0,"mutations","vcf_rider","",null,null],[3,"Coordinate","vcf_rider::mutations","",null,null],[12,"chr","","",7,null],[12,"start","","",7,null],[12,"end","","",7,null],[3,"Mutation","","",null,null],[12,"id","","",8,null],[12,"pos","","",8,null],[12,"sequence_ref","","",8,null],[12,"sequence_alt","","",8,null],[12,"genotypes","","",8,null],[12,"is_indel","","",8,null],[12,"indel_len","","",8,null],[3,"VcfReader","","",null,null],[12,"samples","","",9,null],[4,"Position","","",null,null],[13,"Before","","",10,null],[13,"Overlapping","","",10,null],[13,"After","","",10,null],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"coordinate"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"name":"bool"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"relative_position","","Returns the position of self relative to other.",7,{"inputs":[{"name":"self"},{"name":"coordinate"}],"output":{"name":"position"}}],[11,"relative_position_overlap","","",7,null],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"mutation"}}],[11,"open_path","","",9,{"inputs":[{"name":"str"},{"name":"bool"}],"output":{"name":"result"}}],[11,"next","","",9,{"inputs":[{"name":"self"}],"output":{"name":"option"}}]],"paths":[[3,"Fasta"],[3,"FastaReader"],[3,"PWM"],[3,"Matrix"],[3,"PWMReader"],[3,"RiderParameters"],[8,"CanScoreSequence"],[3,"Coordinate"],[3,"Mutation"],[3,"VcfReader"],[4,"Position"]]};
initSearch(searchIndex);
