- I must consider indel lengths when it comes to overlap when working on windows, so get_overlapping_inner should use a different
  criterium than get_overlapping_outer and use info about lengths of obtained seqs...
- indel stats
let mut groups : Vec<Vec<u8>> = Vec::with_capacity(1);
            groups.push(vec![0 .. n_samples*2]); // in this way it is not easy to understand the group of a sample

            data@tungsteno:/mnt/red/data/bioinfotree/prj/tba_variation/local/src/vcf_rider$ ./target/debug/indel_stats examples/indel.vcf examples/prova.bed
[W::vcf_parse] contig '1' is not defined in the header. (Quick workaround: index the file with tabix.)
bed1    4       1       2       0:1;1:1;2:0;3:0;4:1;5:0;6:0;7:1
[W::vcf_parse] contig '' is not defined in the header. (Quick workaround: index the file with tabix.)
thread 'main' panicked at 'index out of bounds: the len is 0 but the index is 0', /buildslave/rust-buildbot/slave/nightly-dist-rustc-linux/build/src/libcollections/vec.rs:1395
stack backtrace:


- TODO: print overlapping SNPs
- filter vcf inside the lib with the reader?
- length of sequences: meaningfull only after having added SNPs
- docs
- tests

- bug: when bed are overlapping we could lose snps that falls out of the buffer due to the windows inside the bed:

b1 --------------------
w  --- --- --- --- ---
snp .   .       .       .
b2     ---------------

when we arrive at b2 the second snp is long gone in our buffer.

- bed out of chr is not managed:
data@clo:~/work/vcf_rider$ ./target/debug/vcf_rider examples/phased.vcf examples/one_mat examples/prova.bed examples/f2.fasta
bed name: bed2
thread 'main' panicked at 'slice index starts at 6 but ends at 4', ../src/libcore/slice.rs:555
stack backtrace:
   1:     0x5605907f9c39 - std::sys::backtrace::tracing::imp::write::h00e948915d1e4c72
   2:     0x5605907fca5c - std::panicking::default_hook::_{{closure}}::h7b8a142818383fb8
   3:     0x5605907fbf49 - std::panicking::default_hook::h41cf296f654245d7
   4:     0x5605907fc588 - std::panicking::rust_panic_with_hook::h4cbd7ca63ce1aee9
   5:     0x5605907fc3e2 - std::panicking::begin_panic::h93672d0313d5e8e9
   6:     0x5605907fc350 - std::panicking::begin_panic_fmt::hd0daa02942245d81
   7:     0x5605907fc2d1 - rust_begin_unwind
   8:     0x5605908369cf - core::panicking::panic_fmt::hbfc935564d134c1b
   9:     0x560590836b44 - core::slice::slice_index_order_fail::h9ee27d421c31502b
  10:     0x560590772268 - core::slice::_<impl core..ops..Index<core..ops..Range<usize>> for [T]>::index::h4d1325c39b2e2225
                        at /buildslave/rust-buildbot/slave/stable-dist-rustc-linux/build/obj/../src/libcore/slice.rs:577
  11:     0x560590763e04 - _<collections..vec..Vec<T> as core..ops..Index<core..ops..Range<usize>>>::index::hcc671cfe8292d444
                        at /buildslave/rust-buildbot/slave/stable-dist-rustc-linux/build/obj/../src/libcollections/vec.rs:1285
  12:     0x56059077ef82 - vcf_rider::rider::obtain_seq::hfd00545b48b6db2b
                        at /home/data/work/vcf_rider/src/rider.rs:243
  13:     0x56059075f561 - vcf_rider::rider::get_scores::hccc426ed4790678f
                        at /home/data/work/vcf_rider/src/rider.rs:103
  14:     0x560590761953 - vcf_rider::main::h4a398ebb62141879
                        at /home/data/work/vcf_rider/src/main.rs:51
  15:     0x560590804546 - __rust_maybe_catch_panic
  16:     0x5605907fb6c2 - std::rt::lang_start::h53bf99b0829cc03c
  17:     0x560590763d43 - main
  18:     0x7ffabc6a672f - __libc_start_main
  19:     0x5605907476b8 - _start
  20:                0x0 - <unknown>


do we want to do smt better?

[- get MinMax to work]
[- map for Vec<PWM>]
- crate for parameters: https://doc.rust-lang.org/getopts/getopts/index.html   - cargo still do not
 support separate deps for lib and binaries (https://github.com/rust-lang/cargo/issues/1982) - move out the binary in future?
 I do not like the lib very much to tell the truth... will see in the future if n.of arguments gets too cumbersome
 to be managed with the code that I already have.
[- lifetimes!!]
[- read vcf by myself or use lib? gvcf]
- finish loading vcf
- how to have +/min/max/mean in RiderParameters and use it

[- capire iterator cosa fa il for
    // `for` works through an `Iterator` until it returns `None`.
    // Each `Some` value is unwrapped and bound to a variable (here, `i`)
    As a point of convenience for common situations, the for construct turns some collections into iterators using the .into_iterator() method. 
The `iter` method produces an `Iterator` over an array/slice.]

[- capire come mettere print di debug: https://users.rust-lang.org/t/conditional-compilation-for-debug-release/1098]
- implementare i controlli minimali?

- indagare differenza array Vec


min_max
    #[unstable(feature = "core", reason = "return type may change")]
    fn min_max(mut self) -> MinMaxResult<Self::Item> where Self: Sized, Self::Item: Ord
    {
        let (mut min, mut max) = match self.next() {
            None => return NoElements,
            Some(x) => {
                match self.next() {
                    None => return OneElement(x),
                    Some(y) => if x <= y {(x, y)} else {(y, x)}
                }
            }
        };

        loop {
            // `first` and `second` are the two next elements we want to look
            // at.  We first compare `first` and `second` (#1). The smaller one
            // is then compared to current minimum (#2). The larger one is
            // compared to current maximum (#3). This way we do 3 comparisons
            // for 2 elements.
            let first = match self.next() {
                None => break,
                Some(x) => x
            };
            let second = match self.next() {
                None => {
                    if first < min {
                        min = first;
                    } else if first >= max {
                        max = first;
                    }
                    break;
                }
                Some(x) => x
            };
            if first <= second {
                if first < min { min = first }
                if second >= max { max = second }
            } else {
                if second < min { min = second }
                if first >= max { max = first }
            }
        }

        MinMax(min, max)
    }


wtf

    // A `ref` borrow on the left side of an assignment is equivalent to
    // an `&` borrow on the right side.
    let ref ref_c1 = c;
    let ref_c2 = &c;

    println!("ref_c1 equals ref_c2: {}", *ref_c1 == *ref_c2);

    let point = Point { x: 0, y: 0 };

    // `ref` is also valid when destructuring a struct.
    let _copy_of_x = {
        // `ref_to_x` is a reference to the `x` field of `point`.
        let Point { x: ref ref_to_x, y: _ } = point;

        // Return a copy of the `x` field of `point`.
        *ref_to_x
    };

    non ho mica capito il destructuring direi...da solo dei nomi per lo scope?

            // Make a `string` literal and print it:
        let static_string = "I'm in read-only memory";
        println!("static_string: {}", static_string);

        // When `static_string` goes out of scope, the reference
        // can no longer be used, but the data remains in the binary.
